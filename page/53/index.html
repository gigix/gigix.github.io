<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
        page 53 | 透明思考
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    <meta name="author" content="Jeff Xiong">
    
    

    <meta property="og:type" content="website">
<meta property="og:title" content="page 53 | 透明思考">
<meta property="og:url" content="http://gigix.thoughtworkers.org/page/53/index.html">
<meta property="og:site_name" content="透明思考">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="page 53 | 透明思考">

    
    <link rel="alternate" href="/atom.xml" title="透明思考" type="application/atom+xml">
    
    
    <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">

    <script src="/js/jquery.min.js"></script>

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed">

  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">透明思考</a></h1>

        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">
          Transparent Thoughts
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">Blog</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

------------------------------ -->

<nav class="cover-navigation navigation--social">
  <ul class="navigation">


  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/gigix" title="Gigix on GitHub" target="_blank">
      <i class='icon icon-social-github'></i>
      <span class="label">GitHub</span>
    </a>
  </li>

  </ul>
</nav>

          <script>
    function doSearch() {
        var keyword = $('#keyword').val();
        if (keyword.trim() === '') {
            window.location.href = 'http://gigix.thoughtworkers.org/#blog';
        } else {
            window.open('http://www.google.com/search?q=site:gigix.thoughtworkers.org+' + keyword);
        }
    }
</script>

<div class="search">
    <input id="keyword" type="text"/>
    <input type="button" value="Search" class="btn" onclick="doSearch()"/>
</div>


        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            


   <!-- do nothing -->


<div class="main-post-list">
    <ol class="post-list">
    
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/6/4/agile-web-development-with-rails-ii：中文版出版在即/" title="link to Agile Web Development with Rails II：中文版出版在即">Agile Web Development with Rails II：中文版出版在即</a></h2>

      <p class="excerpt">
        <p><span class="caps">CSDN</span>已经放出了<a href="http://book.csdn.net/bookfiles/380/" target="_blank" rel="external">样章试读</a>。目前开放了第4章、第16章和第23章。如果要问这个第二版比起第一版的变化有多大，从这几个样章就能看出来：第4章基本上没有大变化，第16章“数据迁移”是全新的；第23章“Web2.0”虽然标题在第一版里有，内容也是全新的：<a href="http://www.prototypejs.org/" target="_blank" rel="external">Prototype</a>、<a href="http://script.aculo.us/" target="_blank" rel="external">Script.aculo.us</a>和RJS模板。</p><p>目前<a href="http://www.dearbook.com.cn/book/183840" target="_blank" rel="external">第二书店</a>已经开始预订。</p><p>不过，我仍然觉得“xx之道”这种名字真是很土……这次的书是铁道，也就罢了。</p>
      </p>

      <div class="post-list__meta">

        <time datetime="6月 4 2007" class="post-list__meta--date date">6月 4 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/6/3/系统监控工具：monit和runit的比较/" title="link to 系统监控工具：monit和runit的比较">系统监控工具：monit和runit的比较</a></h2>

      <p class="excerpt">
        <p>关于Rails的部署：<a href="http://chinaonrails.com/topic/view/374.html" target="_blank" rel="external">Rails部署艺术</a></p><p>monit作为监控工具有一个缺点：monit会以daemon模式来启动mongrel进程（以及，可能还有，haproxy进程），也就是说每个mongrel需要自己管理PID文件。问题出现在mongrel被意外杀掉的情况：此时PID文件仍然存在，因此monit没办法再用“mongrelstart -d”的命令来启动mongrel。你必须自己想办法清理这些“僵尸PID”文件。</p><p>而runit就比较好：它管理的进程都是自己的子进程，这些子进程以阻塞模式运行，所以也没有PID文件。唯一需要注意的是，haproxy缺省是daemon模式，你需要使用“haproxy-db”把haproxy启动在阻塞模式下。</p><p>所以，用runit来监控mongrel（和haproxy）进程，monit只是看着这些进程有没有异常状况；如果出现异常状况，monit调用sv来重启有问题的服务进程。这就是<a href="http://rubyworks.rubyforge.org" target="_blank" rel="external">RubyWorks</a>目前采用的系统监控策略。</p>
      </p>

      <div class="post-list__meta">

        <time datetime="6月 3 2007" class="post-list__meta--date date">6月 3 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/6/3/沦落｜堕落｜失落/" title="link to 沦落｜堕落｜失落">沦落｜堕落｜失落</a></h2>

      <p class="excerpt">
        <p>不管Google是什么，Google中国（我都恶心于说出“那两个字”）基本上已经沦落到民工一级，在西安火车站赫然陈列。</p><p><a href="http://www.flickr.com/photos/gigix/528715058/" title="Photo Sharing" target="_blank" rel="external"><img src="http://farm1.static.flickr.com/244/528715058_13daabf754.jpg" alt="P1010004" border="0" height="375" width="500"></a></p><p>难道中国就有那么糟糕，让所有——不管曾经多么有品味——的外企都必须在这里堕落么？</p><p><a href="http://www.flickr.com/photos/gigix/528714896/" title="Photo Sharing" target="_blank" rel="external"><img src="http://farm2.static.flickr.com/1049/528714896_19ca2f6d77.jpg" alt="P1010005" border="0" height="375" width="500"></a></p><p>“sigh……太失落了……”</p>
      </p>

      <div class="post-list__meta">

        <time datetime="6月 3 2007" class="post-list__meta--date date">6月 3 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/5/24/铁道下的红宝石：点评ruby畅销书三种/" title="link to 铁道下的红宝石：点评Ruby畅销书三种">铁道下的红宝石：点评Ruby畅销书三种</a></h2>

      <p class="excerpt">
        <p><font face="DejaVu Sans"><font color="#000000"><font size="2">对于</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">这种语言，很多人都和我一样，是因为一个突然风靡全球的、号称能够极大提升</font></font></font><font color="#000000"><font size="2">web</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">应用开发效率的、名叫</font></font></font><font color="#000000"><font size="2">Rails</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">的</font></font></font><font color="#000000"><font size="2">web</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">框架而顺带了解到的。在为</font></font></font><font color="#000000"><font size="2">Rails</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">的神奇魔力所折服的同时，我们也常常心生疑惑：这种强大的力量究竟来自何方？如果换成</font></font></font><font color="#000000"><font size="2">Java</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">、</font></font></font><font color="#000000"><font size="2">C#</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">或是别的什么语言，一个</font></font></font><font color="#000000"><font size="2">web</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">框架能否同样高效？除了这多少有些“虚”的思考之外，我们还常常在各大论坛上看到“应该如何学习</font></font></font><font color="#000000"><font size="2">Ruby”</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">这样的问题——</font></font></font><font color="#000000"><font size="2">Rails</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">尽管方便易用，但要真正穷其千里目，仍须在</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">语言这里更上一层楼才行。</font></font></font></p><p><font face="DejaVu Sans"><font color="#000000"><font size="2">好在书中自有黄金屋。不论是要深入探索</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">语言的奥妙之处，还是只想在工作中遇到问题时查找参考，都有好书可以提供帮助。在</font></font></font><font color="#000000"><font size="2">Amazon</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">网站上，抛开专讲</font></font></font><font color="#000000"><font size="2">Rails</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">框架的</font></font></font><font color="#000000"><font size="2">Agile Web Development with Rails</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">之外，销量排名前三位的</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">图书分别是</font></font></font><font color="#000000"><font size="2">Programming Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">（第二版）、</font></font></font><font color="#000000"><font size="2">Ruby Cookbook</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">和</font></font></font><font color="#000000"><font size="2">The Ruby Way</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">（第二版）。</font></font></font></p><h1 class="western"><font face="Bitstream Vera Sans"><font color="#000000"><font size="3"><b>镐头书：</b></font></font></font><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="3"><b>Programming Ruby</b></font></font></font><font face="Bitstream Vera Sans"><font color="#000000"><font size="3"><b>（第二版）</b></font></font></font></h1><p><font face="DejaVu Sans"><font color="#000000"><font size="2">由于封面上赫然画着一柄丁字镐，这本</font></font></font><font color="#000000"><font size="2">Programming Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">也被</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">程序员们亲切地昵称为“镐头书”——和历史上大名鼎鼎的“龙书”、“紫皮书”一样，拥有一个独特的昵称本身就证明了这本书的地位。虽然</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">语言的作者</font></font></font><font color="#000000"><font size="2">Matsumoto</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">并没有参与撰写此书，但</font></font></font><font color="#000000"><font size="2">Dave Thomas</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">和</font></font></font><font color="#000000"><font size="2">Andy Hunt</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">这两位“用本主义程序员”的大名也足以撑起一部经典教材了。</font></font></font></p><p><font color="#000000"><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">所以这本书就是</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Ruby</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">的经典教材。关于</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Ruby</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">的基本语法和常用工具，书中第一部分和第二部分做了详细的介绍。第三部分“</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Ruby Crystallized”</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">更加阐述了</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Ruby</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">语言的一些细节和设计理念，其中第</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">23</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">章“</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Duck Typing”</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">是刚从</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Java</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">或者</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">.NET</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">平台走出来的读者不可错过的，因为对于类型与契约的理解、对于类与类型的理解，正是</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Ruby</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">这种动态语言与</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Java/C#</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">等静态语言最大的区别之一。随后的第四部分提供了</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font size="2">Ruby</font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">基础类库的速查手册。</font></font></font></font></font></p><p><font color="#000000"><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">身为“用本主义程序员”的两位作者并非浪得虚名：这本</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Programming Ruby</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">虽然不是一本称职的参考手册，却足够帮助一个初学者步入</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">世界而不致误入歧途，并且能够在很少见的一些情况下——譬如说忘了</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">yield</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">的用法——给有经验的</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">程序员提供帮助。在我看来，这也就足够奠定它作为经典教材的地位了。</font></font></font></font></font></p><h1 class="western" align="left"><font face="Bitstream Vera Sans"><font color="#000000"><font size="3"><b>不可读，不可不读：</b></font></font></font><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="3"><b>Ruby Cookbook</b></font></font></font></h1><p><font color="#000000"><font color="#000000">“</font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">写作这本书是为了帮你节约时间。人们常说‘时间就是金钱’，没错，不过别忘了，时间还是你的生命。我们有限的生命最好是用于创造有趣的新事物，而不是跟自己的错误较劲，或是试图解决那些早已有人解决过的问题。我们花了不少时间来写这本书，只希望它帮助所有读者节约的时间能够值回票价。”</font></font></font></font></font></p><p><font color="#000000"><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">这段话出自</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Lucas Carlson</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">和</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Leonard Richardson</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">两位作者为</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby Cookbook</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">所写的前言。说得没错。人们把太多的时间浪费在实现通用算法、做别人已经做过的事、调试错误和重复劳动上；在想要避免重复劳动时，他们又把太多的时间浪费在搜索、试用和学习别人提供的库上。就像两位作者所说，这本</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby Cookbook</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">的问世正是为了帮助人们节省这些时间。</font></font></font></font></font></p><p><font color="#000000"><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">而它也毫无疑问能够兑现自己的承诺。这本</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Cookbook</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">涵盖的内容从字符串处理到数组与</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Hash</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">的用法、从代码块到元编程、从文件读写到数据库持久化、从互联网服务到分布式</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">程序设计……简而言之，</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">程序设计中的各种常见问题在这里都有所提及。除了编程任务之外，这本书还包括了测试、调试、性能优化、打包发布、日常任务自动化等内容。说得夸张一点，也许</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">程序员们遇到问题时第一个咨询的对象不应该是</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Google</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">，而是这本</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby Cookbook</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">。</font></font></font></font></font></p><p><font color="#000000"><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">但——在我个人看来——它有一个致命的缺点：太过厚重。涵盖如此大量的内容，代价就是两位作者把这本书写到了近千页之厚。当然我们并不是没读过厚达千余页的大书，但</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Ruby</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">毕竟不是</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">C++</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">，如何期望那些满怀激情的</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">web 2.0</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">创业者捧着一本鸿篇巨著正襟危坐孜孜苦学？所以，也许你应该把这本书放在案头，遇到问题时立即翻查，但你很可能不会有兴趣去细细读它。</font></font></font></font></font></p><h1 class="western" align="left"><font face="Bitstream Vera Sans"><font color="#000000"><font size="3"><b>解说</b></font></font></font><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="3"><b>Ruby</b></font></font></font><font face="Bitstream Vera Sans"><font color="#000000"><font size="3"><b>之道：</b></font></font></font><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="3"><b>The Ruby Way</b></font></font></font></h1><p><font color="#000000"><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">在</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Rails</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">变得炙手可热之后，我不止一次地听到这样一种——不无醋意的——论调：只要学习</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Rails</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">框架的设计思想，用别的语言（譬如</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">Java</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">）也能够做出同样优雅、同样高效的</font></font></font></font><font face="Verdana, sans-serif"><font size="2"><font color="#000000"><font face="Bitstream Vera Sans, serif"><font size="2">web</font></font></font></font></font><font face="DejaVu Sans"><font size="2"><font color="#000000"><font size="2">框架。其实正如维特根斯坦曾说的，语言本身已经为思想划下了界限。选择一种语言远远不止是选择它的语法，还意味着选择其中的模式、惯用法、套路和思维方式。或者说得更玄一点，你不仅要接受它的“器”，更重要的是掌握它的“道”。</font></font></font></font></font></p><p><font face="DejaVu Sans"><font color="#000000"><font size="2">但“道”是很难形容的。“我能够感受到它，但未曾尝试过用语言来解释它。这太难了，即使是用我的母语日语。但</font></font></font><font color="#000000"><font size="2">Hal Fulton</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">这样做了，且第一次就做得很不错。由于得到了</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">社区许多人的帮助，他的第二次尝试更出色。”</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">语言的创造者</font></font></font><font color="#000000"><font size="2">Matsumoto</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">如是说。从篇章选材来说，</font></font></font><font color="#000000"><font size="2">Fulton</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">所著的这本</font></font></font><font color="#000000"><font size="2">The Ruby Way</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">与前面介绍的</font></font></font><font color="#000000"><font size="2">Ruby Cookbook</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">大同小异：无非是各方面的常见问题及其解决方案。不同之处在于：它不仅讲解如何解决这些问题，还揭示出解决方案背后隐藏着的</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">的思维方式——</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">之道。这也让这本书——尽管其厚度并不逊于</font></font></font><font color="#000000"><font size="2">Ruby Cookbook——</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">有了更多的可读性。</font></font></font></p><p><font face="DejaVu Sans"><font color="#000000"><font size="2">作者把“</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">之道”分为两部分：</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">设计的哲学，以及“如何使用</font></font></font><font color="#000000"><font size="2">Ruby”</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">的哲学。</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">语言具有某种“无名特质”，其中最大的特点就是“简单”：它让程序员们能够以更简单的方式解决问题。但</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">并不是一种简单的语言——简直可以说它“相当复杂”。那么，这种复杂的语言是如何让使用者的生活反而变得简单的？了解其中的奥妙，不仅有益于快速掌握</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">语言，对于读者今后的软件设计思路也不无裨益。带着这个问题来阅读这本</font></font></font><font color="#000000"><font size="2">The Ruby Way</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">，相信读者能够更好地看出作者的良苦用心。</font></font></font></p><p><font face="DejaVu Sans"><font color="#000000"><font size="2">作为“</font></font></font><font color="#000000"><font size="2">Web 2.0</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">时代”的产物，这本书的第二版相比第一版也加入了很多新鲜内容，例如测试驱动、开发工具、社区介绍等等。此外</font></font></font><font color="#000000"><font size="2">Rails</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">的作者</font></font></font><font color="#000000"><font size="2">David Heinemeier Hansson</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">也指出：本书在阐述元编程，很多</font></font></font><font color="#000000"><font size="2">Rail</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">理念的灵感都来自本书的第一版，尤其是现为第</font></font></font><font color="#000000"><font size="2">11</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">章的内容。不过如果你恰好是刚开始接触</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">，我强烈建议你从第</font></font></font><font color="#000000"><font size="2">14</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">章“脚本编程与系统管理”读起，因为学习一种编程语言的最佳途径就是从现在开始用它，每天都用。</font></font></font></p><p lang="en-US" align="center"><font color="#000000"><font size="2"><em> </em> *</font></font></p><p><font face="DejaVu Sans"><font color="#000000"><font size="2">诚如</font></font></font><font color="#000000"><font size="2">Martin Fowler</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">所说，</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">是一种神奇的语言。不论你是被这种神奇的语言本身所吸引，还是为了赶上</font></font></font><font color="#000000"><font size="2">Rails</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">的热潮而学习</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">语言，本文所介绍的三本书应该就能满足你的需要。其实除了</font></font></font><font color="#000000"><font size="2">Rails</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">之外，</font></font></font><font color="#000000"><font size="2">Ruby</font></font><font face="DejaVu Sans"><font color="#000000"><font size="2">的世界里还有众多的“红宝石”闪烁着迷人的光芒，但愿这几本书能帮你发现更多“铁道下的红宝石”。最后，就祝你阅读愉快、编程愉快吧。</font></font></font></p>
      </p>

      <div class="post-list__meta">

        <time datetime="5月 24 2007" class="post-list__meta--date date">5月 24 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/5/20/转载-rubyworks入门指南/" title="link to (转载)RubyWorks入门指南">(转载)RubyWorks入门指南</a></h2>

      <p class="excerpt">
        <p></p><p>（抄袭<a href="http://lightyror.thegiive.net/" target="_blank" rel="external">Giive Chen</a>的<a href="http://lightyror.thegiive.net/2007/05/rubyworks-001-release.html" target="_blank" rel="external">RubyWorks 0.0.1Release</a>，感谢Giive的帮助<sup>_</sup>）</p><p>如果你覺得安裝所有的 Ruby on Rails 相關套件，並且將 Production Server系統設定好是一件很麻煩的事情嗎？或許你可以試試看<a href="http://rubyworks.rubyforge.org/" target="_blank" rel="external">RubyWorks</a>。</p><p>RubyWorks是一個在 Red Hat Enterprise 或是 CentOS 上面的套件組合，他會幫你把所有 Production 環境下面的相關的Ruby on Rails 套件跟 Server 套件一次安裝完成，並且提供一個馬上可以跑的 defulat configfile，也就是說各位公司的技術長們不需要花時間去看那麼多 Production 設定方式，你已經有一個很堪用的 ProductionRuby on Rails Server了。</p><p>So，你還有理由不玩 Ruby on Rails嗎？</p><p>我們看看怎麼安裝 RubyWorks，因為我沒有 Red Hat Enterprise Server，所以我只 Test CentOS。</p><p><strong>前置作業</strong></p><p>RubyWorks 因為好像還沒進去 yum 資料庫，所以我們還是得必須告訴 yum 哪裡有 RubyWorks 的 Package，如果已經進去yum repo了，就好像不需要這個動作了。</p><p>如果你像我一樣，是個不求甚解，只求可以 Work 的人，就這樣打就好了。</p><blockquote>wget <a href="http://rubyworks.rubyforge.org/public_key.txt" target="_blank" rel="external">http://rubyworks.rubyforge.org/public_key.txt</a><div class="code">sudo rpm—import public_key.txt<br><div class="code">wget <a href="http://rubyworks.rubyforge.org/RubyWorks.repo" target="_blank" rel="external">http://rubyworks.rubyforge.org/RubyWorks.repo</a></div><div class="code">cp RubyWorks.repo /etc/yum.repos.d/<br><br></div></div></blockquote><div class="code"><div class="code"><strong><span class="caps">YUM</span>安裝 Ruby Works</strong><br>直接用 gem 安裝<br><blockquote>yum install rubyworks</blockquote><strong>然後…..裝好了。</strong><br><br></div>請連線到 <a href="http://localhost:3001/" target="_blank" rel="external">http://localhost:3001/</a> 的地方，你一定會看到一個很熟悉的畫面。是的，Ruby on Rails已經跑起來了，還是用 Haproxy 幫你跑的。不過這裡要講的是，因為他的取向不是 development server，而是production server，所以他並不會安裝 Rails 的 gem package，而是直接將 rails 放在<em>/usr/rails/vender/rails</em>裡面。<br><br><strong>Rubyworks 安裝表</strong><br><br>RubyWorks 一共會幫你安裝<br><ul><li><strong>ruby</strong></li><li><strong>ruby-devel</strong></li><li><strong>rubygems</strong></li><li><strong>haproxy</strong></li><li><strong>monit</strong></li><li>mongrel</li><li><strong>rubyworks</strong></li></ul>並且幫你設定好 HAProxy ，跑在 3001 Port，Mongrel 跑在 3002~3005 Port，monit 跑在 2812 port。<br><br><strong>Rubyworks 詳細位置表</strong><br><br>詳細的安裝位置是在<br><ol><li><code>/usr/bin/ruby/</code>：Ruby 所在地</li><li><code>/usr/lib/ruby/</code>：Ruby libraries</li><li><code>/usr/lib/ruby/1.8/</code>：Ruby standard library</li><li><code>/usr/lib/ruby/gems/1.8/gems/</code>：所有安裝的 Ruby gems Package</li><li><code>/usr/bin/monit</code>：monit 執行檔</li><li><code>/etc/init.d/monit</code>：monit的啟動 script，所有的 server 都會在 monit啟動的時候，也順便幫你啟動好了（Mongrel，Haproxy）</li><li><code>/usr/bin/haproxy</code>：HAProxy 執行檔</li><li><code>/usr/bin/mongrel_rails</code>：Mongrel</li><li><code>/etc/rails/</code>：configuration files</li><li><code>/var/rails/</code>：所有 Deamon 的 .pid files</li><li><code>/usr/rails/</code>：Rails app code 所在地。</li><li><code>/var/log/monit.log</code>：Monit 的 log</li><li><code>/var/log/haproxy.log</code>：HAProxy log</li><li><code>/usr/rails/log/</code>：Mongrels and Rails 的 log</li></ol></div><b>延伸閱讀</b><ul><li><a href="http://rubyworks.rubyforge.org/" target="_blank" rel="external">RubyWorks 網頁</a></li><li><a href="../../articles/2007/05/16/rubyworks-initial-release">RubyWorks 0.0.1 Released</a></li></ul><p></p>

      </p>

      <div class="post-list__meta">

        <time datetime="5月 20 2007" class="post-list__meta--date date">5月 20 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/5/19/不用说（或者随便怎么说）/" title="link to 不用说（或者随便怎么说）">不用说（或者随便怎么说）</a></h2>

      <p class="excerpt">
        <p>今天在<a href="http://agilexa.thoughtworkers.org/" target="_blank" rel="external">敏捷西安</a>做了关于<a href="http://rubyworks.rubyforge.org/" target="_blank" rel="external">RubyWorks</a>的<a href="http://agilexa.googlegroups.com/web/enterprise_ruby.ppt?gda=gnf5_UQAAABHNVgv_zjz6SJL1ZdfIznDTrHLrordqL8TPnttocn_UGG1qiJ7UbTIup-M2XPURDRofGAAaZ-AGpHVjmoefGXg6coCigX_y4kVdZrur1jNxg" target="_blank" rel="external">演讲</a>。在准备讲稿的时候，随便乱看，就看到了孟岩以前的一个blog：<a href="http://blog.csdn.net/myan/archive/2006/09/25/1281151.aspx" target="_blank" rel="external">动态语言，别再说不</a>。</p><p>“国外的大气候和国内的小气候都有共同特点，就是站在传统技术立场上的人对于RoR的火爆看不下去了，首先站出来发难，从而引发Ruby支持者们的回击，然后双方厮杀在一起，连带旁边相干不相干的看热闹的、拉架的、含沙射影的、慷慨激昂的，瞬间就浩浩荡荡，横无际涯了。而争论来争论去，无非还是Ruby的性能问题、可用性问题、前景问题，等等等等。”</p><p>孟岩的态度——如果我没理解错的话——是在劝解大家，不要随便怀疑新生事物，新生事物旺盛的生命力是能够克服一切困难的，要对新生事物抱有希望。而我（现在）的态度是，我不劝说谁。不是怀疑性能问题吗？我们做出<a href="../../articles/2007/05/16/rubyworks-initial-release">唾手可得的高性能部署环境</a>放在这儿。不是担心跟遗留系统不方便整合吗？我们把遗留数据库和消息系统的问题都解决掉。不是没有看到成熟案例吗？我们就来做成熟案例。</p><p>既然对它有信心，那就动手把所有的怀疑都打消掉。人们怀疑什么，我们就解决什么。</p><p>至于<a href="../../articles/2007/04/22/how-to-educate-the-mass">教育大众</a>的事情么……我很相信，我们只要教育“小众”——多半是“大众”们的老板——就行了，“小众”会帮我们教育大众的。</p><p>所以孟岩希望大众“别再说不”，我的态度是，大众随便怎么说，我无所谓。</p>
      </p>

      <div class="post-list__meta">

        <time datetime="5月 19 2007" class="post-list__meta--date date">5月 19 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/5/18/rails部署：反向代理优于fastcgi/" title="link to Rails部署：反向代理优于FastCGI">Rails部署：反向代理优于FastCGI</a></h2>

      <p class="excerpt">
        <p><a href="http://rubyworks.rubyforge.org" target="_blank" rel="external">RubyWorks</a>采用了基于反向代理和Mongrel的部署方案：HAProxy把请求代理给不同的Mongrel实例。在<a href="http://www.infoq.com/cn/news/2007/05/rubyworks" target="_blank" rel="external">InfoQ中文站的报道</a>中写道：</p><p>“RubyWorks项目领导人<a href="mailto:alexey.verkhovsky@gmail.com" target="_blank" rel="external">Alexey Verkhovsky</a>也认为，只有在对节约内存使用非常重视的情况下（例如虚拟共享主机），FastCGI才有其价值；而在普通的企业应用中，可靠性和可管理性重于节约内存，这也是RubyWorks选择基于反向代理和Mongrel的部署方案的原因。”</p><p>在《<a href="http://www.china-pub.com/computers/common/info.asp?id=30058" target="_blank" rel="external">Agile Web Development withRails</a>》的第一版中所推荐的部署方案是基于FastCGI的，而第二版则改为推荐基于反向代理的部署方案。James Duncan Davidson在书中写道：</p><p>“ 简而言之，FastCGI确实是一枚火箭，但有时会因为各种奇怪的原因而爆炸在发射台上。使用代理让Rails应用直接与HTTP对话，这是整个社群的发展方向。”</p><p>即使在<a href="http://www.dreamhost.com" target="_blank" rel="external">DreamHost</a>这样的shared host上，FastCGI也给人们带来了<a href="http://nubyonrails.com/articles/2005/11/16/yet-another-chapter-in-the-fcgi-saga" target="_blank" rel="external">种种困扰</a>，这也是Mongrel（以及相应的，反向代理的部署方案）流行的原因。另一个Rails服务器<a href="http://swiftiply.swiftcore.org/index.html" target="_blank" rel="external">Swiftiply</a>号称比Mongrel更高性能，不过伸缩性方面都是线性的。</p>
      </p>

      <div class="post-list__meta">

        <time datetime="5月 18 2007" class="post-list__meta--date date">5月 18 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/5/16/rubyworks-0-0-1-released/" title="link to RubyWorks 0.0.1 Released">RubyWorks 0.0.1 Released</a></h2>

      <p class="excerpt">
        <p><a href="http://rubyworks.rubyforge.org/" target="_blank" rel="external">RubyWorks</a>production stack is a collection of open-source software required to host a<a href="http://www.rubyonrails.org" target="_blank" rel="external">RubyOnRails</a>application on a RedHat Enterprise Linux 4 or CentOS 4 server.</p><p>Once you point your package manager (up2date or yum) to RubyWorks repository and install thepackage, you have all the necessary pieces preconfigured and ready to go. Moreover, there is askeleton Rails application up and running on the server. It’s as close as we could get toone-click production deployment with Rails.</p><p>前一阵的冲锋有了成果。在即将开幕的<a href="http://conferences.oreillynet.com/rails/" target="_blank" rel="external">RailsConf 2007</a>上，所有人都将看到我们的RubyWorks。</p><p>正如<a href="http://gigix.thoughtworkers.org/articles/2007/04/20/ruby-on-rails-is-enterprise-ready">我以前说过的</a>，Ruby和Rails已经做好了准备走向企业。在众多怀疑的部署问题（性能、伸缩性、可靠性、可管理性……）上，一个<a href="http://gigix.thoughtworkers.org/articles/2007/04/24/deploy-rails-app-with-haproxy-and-mongrel">经过实践检验的部署方案</a>已经存在，事实证明它完全能够应付所谓“企业级”的要求——不论你如何定义“企业级”这个词，因为这个部署方案各方面的能力已经证明了它自己。</p><p>唯一的问题是，<a href="http://haproxy.1wt.eu/" target="_blank" rel="external">HAProxy</a>、<a href="http://www.tildeslash.com/monit/" target="_blank" rel="external">Monit</a>、<a href="http://mongrel.rubyforge.org/" target="_blank" rel="external">Mongrel</a>的配置即令不是困难的，至少也不是易如反掌的。RubyWorks的出现正是为了解决这个问题。我们提供一个“高性能”“企业级”（如果你喜欢这些大词的话）Rails部署环境所需的所有软件，以及可以立刻投入使用的缺省配置，再加上一个示例应用。所有这些都以RPM的形式发布，用yum或者up2date就可以直接安装。如果你正在开发Rails应用并且你的部署环境是Redhat/Fedora/CentOS，那么恭喜你了，因为……</p><p>高性能的Rails部署应用服务器，现在只需一分钟就可以获得。</p>
      </p>

      <div class="post-list__meta">

        <time datetime="5月 16 2007" class="post-list__meta--date date">5月 16 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/5/14/所谓“科学的根基”/" title="link to 所谓“科学的根基”">所谓“科学的根基”</a></h2>

      <p class="excerpt">
        <p>（以下文字摘录自波普尔《<a href="http://www.chineseliterature.com.cn/zongjiao/krbob-kxfxdlj/" target="_blank" rel="external">科学发现的逻辑</a>》。）</p><p>科学理论是全称陈述。</p><p>自然科学的理论，特别是所谓自然定律，具有严格全称陈述的逻辑形式；因此它们可以被表达成严格存在陈述的否定形式，或者可以称作非存在陈述（或“无”陈述）。例如，能量守恒定律可以表达为这样的形式“不存在永动机”，基本电荷的假说可以表达为这样的形式：“除了基本电荷的倍数以外，不存在任何电荷”。</p><p>自然定律可以和“排斥”或“禁止”相比拟。它们并不断言什么东西存在着或具有某种状态；而是否定它。它们坚持一定的事物或状态的不存在，可以说是排斥或禁止这些事物或状态：自然定律排除它们。正因如此，它们是可证伪的。</p><p>在一个理论系统或公理系统必须满足的各种要求中间，无矛盾性要求起着特殊的作用。它可被看作每一个理论系统，不论它是经验的还是非经验的，都要满足的第一个要求。在无矛盾性以外，经验系统必然满足进一步的条件：它必须是可证伪的，这两个条件在很大程度上是类似的。</p><p>如果我们要求用推理的论证在逻辑的意义上去证明［科学陈述］，那么我们就得接受这样的看法：陈述只能为陈述所证明。因而，要求所有的陈述都要被合乎逻辑地证明（Fries称作“对证明的偏爱”）一定会导致无穷后退。</p><p>理论是或多或少可以严格地检验的；这就是说，或多或少可以容易地证伪的。它们的可检验性的程度对于理论的选择是有意义的。“它们禁止越多，它们说得越多”。</p>
      </p>

      <div class="post-list__meta">

        <time datetime="5月 14 2007" class="post-list__meta--date date">5月 14 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
    <li class="post">

      <h2 class="post-list__post-title post-title"><a href="/2007/5/10/dsl不要太多/" title="link to DSL不要太多">DSL不要太多</a></h2>

      <p class="excerpt">
        <p><a href="http://activeform.rubyforge.org/" target="_blank" rel="external">ActiveForm</a>据说是用来生成HTML表单的DSL。<a href="http://dongbin.javaeye.com/blog/74784" target="_blank" rel="external">董斌</a>还颇赞赏。</p><p>然则，这个代码真的比HTML更容易弄吗？</p><p><span class="caps">HTML</span>原本就被认为是描述web界面的DSL，现在又弄出一套DSL来生成HTML。</p><p>用好现在的工具，会不会比不断发明新工具要好？</p>
      </p>

      <div class="post-list__meta">

        <time datetime="5月 10 2007" class="post-list__meta--date date">5月 10 2007</time> &#8226; 

        <span class="post-list__meta--tags tags">
          <font class="categories">
            
          </font>
          

        </span>
      </div>

      <hr class="post-list__divider" />
    </li>
    
  </ol>

  <hr class="post-list__divider " />

<nav class="pagination" role="navigation">
    
    	
          <a class="newer-posts pagination__newer btn btn-small btn-tertiary" href="/page/52/">&larr; Newer Posts</a>
        
    

    <span class="pagination__page-number">Page 53 of 56</span>
    
    
        <a class="older-posts pagination__older btn btn-small btn-tertiary" href="/page/54/">Older Posts &rarr;</a>
    
</nav>


</div>			
            <footer class="footer">
    <span class="footer__copyright">&copy;
        作者保留一切权利，未经许可请勿转载</span>
    <span class="footer__copyright">&copy;
        2018
        Transparent Thoughts. All rights reserved.</span>
</footer>
        </div>
    </div>

    <!-- The main JavaScript file for Casper -->
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    <script src="/js/jquery.imagesloaded.min.js"></script>
    <script src="/js/gallery.js"></script>
    <script src="/js/jquery.githubRepoWidget.min.js"></script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config"> 
      MathJax.Hub.Config({ 
        tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
    }); 

    </script>

    <!--kill ie6 -->
    <!--[if IE 6]>
    <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
    <![endif]-->

    <!-- totop -->
    <div id="totop" style="position:fixed;bottom:50px;right:30px;cursor: pointer;">
        <a title="back to top"><img style="width:30px;height:30px;" src="/images/totop.png"/></a>
    </div>
    <script>
        (function ($) {
            var upperLimit = 100;
            var scrollElem = $('#totop');
            var scrollSpeed = 500;
            scrollElem.hide();
            $(window).scroll(function () {
                var scrollTop = $(document).scrollTop();
                if (scrollTop > upperLimit) {
                    $(scrollElem).stop().fadeTo(300, 1); // fade back in
                } else {
                    $(scrollElem).stop().fadeTo(300, 0); // fade out
                }
            });
            $(scrollElem).click(function () {
                $('html, body').animate({scrollTop: 0}, scrollSpeed);
                return false;
            });
        })(jQuery);
    </script>

    <!-- fancybox -->
    
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
    <script src="/fancybox/jquery.fancybox.pack.js"></script>
    <script type="text/javascript">
        (function ($) {
            $('.fancybox').fancybox();
        })(jQuery);
    </script>
    

    <!-- Google Analytics -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-113927-4', 'auto');
        ga('send', 'pageview');
    </script>

    <!-- CNZZ Analytics -->
    <script src="http://s4.cnzz.com/z_stat.php?id=1255092465&web_id=1255092465" language="JavaScript"></script>

</body>
</html>
